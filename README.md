# Микросервис управления документами

Микросервис для управления документами с вложенной структурой, построенный на принципах Clean Architecture. Реализован на языке Go с использованием базы данных Reindexer в качестве отдельного сервиса.

## Содержание

- [Возможности](#возможности)
- [Технологический стек](#технологический-стек)
- [Архитектура](#архитектура)
- [Требования](#требования)
- [Быстрый старт](#быстрый-старт)
- [Конфигурация](#конфигурация)
- [API Документация](#api-документация)
- [Модель данных](#модель-данных)
- [Разработка](#разработка)
- [Тестирование](#тестирование)
- [Docker](#docker)
- [Лицензия](#лицензия)

## Возможности

- **CRUD операции** - Полный набор операций для работы с документами
- **Вложенная структура** - Поддержка двухуровневой вложенности элементов
- **Автоматическая сортировка** - Элементы первого уровня сортируются по полю `sort` (по убыванию)
- **Кэширование** - Шардированный in-memory кэш с TTL 15 минут
- **Пагинация** - Эффективное получение списка документов с поддержкой пагинации
- **Health Checks** - Проверка состояния сервиса и подключения к базе данных
- **Rate Limiting** - Ограничение количества одновременных запросов
- **Фоновая обработка** - Асинхронная обработка документов
- **Graceful Shutdown** - Корректное завершение работы с ожиданием завершения текущих операций

## Технологический стек

- **Go 1.21+** - Язык программирования
- **Reindexer** - База данных (отдельный сервис, cproto binding)
- **Docker & Docker Compose** - Контейнеризация
- **Zap** - Структурированное логирование
- **Viper** - Управление конфигурацией
- **Chi** - HTTP роутер
- **Make** - Автоматизация задач (опционально)

## Архитектура

Проект построен на принципах **Clean Architecture** и разделен на следующие слои:

### Слои архитектуры:

- **Domain** - Бизнес-сущности и интерфейсы
- **Use Cases** - Бизнес-логика приложения
- **Repositories** - Слой доступа к данным (Reindexer)
- **Handlers** - HTTP API обработчики
- **Infrastructure** - Кэш, логгер, конфигурация

### Структура проекта:

```
.
├── cmd/
│   └── server/              # Точка входа приложения
├── internal/
│   ├── cache/               # Реализация шардированного кэша
│   ├── config/              # Управление конфигурацией
│   ├── domain/              # Доменные сущности и интерфейсы
│   ├── handlers/            # HTTP обработчики
│   ├── middleware/           # HTTP middleware
│   ├── processor/           # Фоновая обработка документов
│   ├── repositories/        # Слой доступа к данным
│   └── usecases/            # Бизнес-логика
├── pkg/
│   └── logger/              # Структурированное логирование
├── docker-compose.yml       # Конфигурация Docker сервисов
├── Dockerfile              # Образ приложения
├── config.yaml.example     # Пример конфигурации
├── go.mod                  # Зависимости Go
└── README.md               # Документация
```

## Требования

- **Docker** & **Docker Compose** (для запуска через Docker)
- **Go 1.21+** (для локальной разработки)
- **Make** (опционально, для удобства)

## Быстрый старт

### Использование Docker Compose (Рекомендуется)

Docker Compose автоматически запускает два сервиса: Reindexer (база данных) и приложение. Приложение ожидает готовности Reindexer перед запуском.

```bash
# Запуск всех сервисов (Reindexer + приложение)
docker-compose up -d

# Просмотр логов приложения
docker-compose logs -f app

# Просмотр логов Reindexer
docker-compose logs -f reindexer

# Просмотр логов всех сервисов
docker-compose logs -f

# Остановка всех сервисов
docker-compose down
```

### Локальная разработка

Для локальной разработки необходимо запустить Reindexer отдельно (через Docker или установить локально). По умолчанию приложение подключается к `cproto://localhost:6534/db`.

```bash
# Установка зависимостей
go mod download

# Запуск тестов
go test ./...

# Сборка приложения
go build -o server ./cmd/server

# Запуск приложения
# Убедитесь, что Reindexer запущен на localhost:6534
./server
```

**Примечание:** Для локальной разработки можно запустить только Reindexer через Docker:
```bash
docker run -d -p 6534:6534 -p 9088:9088 --name reindexer reindexer/reindexer:latest
```

## Конфигурация

### Переменные окружения

| Переменная | По умолчанию | Описание |
|------------|--------------|----------|
| `APP_SERVER_HOST` | `0.0.0.0` | Хост сервера |
| `APP_SERVER_PORT` | `8080` | Порт сервера |
| `APP_REINDEXER_DSN` | `cproto://localhost:6534/db` | Строка подключения к Reindexer (в Docker: `cproto://reindexer:6534/db`) |
| `APP_REINDEXER_NAMESPACE` | `default` | Namespace Reindexer |
| `APP_REINDEXER_MAX_CONNECTIONS` | `10` | Максимальное количество соединений с БД |
| `APP_CACHE_TTL` | `900` | TTL кэша в секундах (15 минут) |
| `APP_CACHE_SHARDS` | `16` | Количество шардов кэша |
| `APP_CONCURRENCY_HTTP_MAX_WORKERS` | `100` | Максимум одновременных HTTP запросов |
| `APP_CONCURRENCY_PROCESSOR_WORKERS` | `10` | Количество воркеров для фоновой обработки |
| `APP_CONCURRENCY_CACHE_SHARDS` | `16` | Количество шардов кэша (дублирует APP_CACHE_SHARDS) |
| `APP_CONCURRENCY_DB_MAX_CONNECTIONS` | `10` | Максимум соединений с БД (дублирует APP_REINDEXER_MAX_CONNECTIONS) |
| `APP_CONFIG_PATH` | `config.yaml` | Путь к файлу конфигурации |

### Файл конфигурации

Скопируйте `config.yaml.example` в `config.yaml` и настройте параметры:

```yaml
server:
  host: "0.0.0.0"
  port: 8080

reindexer:
  dsn: "cproto://localhost:6534/db"  # В Docker Compose используйте: cproto://reindexer:6534/db
  namespace: "default"
  max_connections: 10

cache:
  shards: 16
  ttl: 900  # 15 минут в секундах

concurrency:
  http_max_workers: 100      # Максимум одновременных HTTP запросов
  processor_workers: 10      # Количество воркеров для фоновой обработки
  cache_shards: 16           # Количество шардов кэша
  db_max_connections: 10      # Максимум соединений с БД
```

**Примечание:** При запуске через Docker Compose переменная `APP_REINDEXER_DSN` автоматически устанавливается в `cproto://reindexer:6534/db`, где `reindexer` - это имя сервиса в Docker Compose. Для локальной разработки используйте `cproto://localhost:6534/db`.

## API Документация

Базовый URL: `http://localhost:8080`

Все запросы и ответы используют формат JSON. В заголовках ответов присутствует `X-Request-ID` для отслеживания запросов.

### Формат ошибок

При возникновении ошибки сервер возвращает JSON в следующем формате:

```json
{
  "error": "Описание ошибки",
  "request_id": "уникальный-идентификатор-запроса"
}
```

### Коды состояния HTTP

- `200 OK` - Успешный запрос
- `201 Created` - Ресурс успешно создан
- `400 Bad Request` - Некорректный запрос
- `404 Not Found` - Ресурс не найден
- `500 Internal Server Error` - Внутренняя ошибка сервера
- `503 Service Unavailable` - Сервис недоступен

---

### Health Check

Проверка состояния сервиса и подключения к базе данных.

**Endpoint:** `GET /health`

**Описание:** Возвращает статус сервиса и состояние подключения к базе данных.

**Запрос:**
```bash
curl -X GET http://localhost:8080/health
```

**Успешный ответ (200 OK):**
```json
{
  "status": "ok",
  "timestamp": 1699123456,
  "database": "connected"
}
```

**Ответ при недоступности БД (503 Service Unavailable):**
```json
{
  "status": "unhealthy",
  "timestamp": 1699123456,
  "error": "описание ошибки"
}
```

---

### Документы

#### Создание документа

**Endpoint:** `POST /documents`

**Описание:** Создает новый документ с вложенными элементами.

**Запрос:**
```bash
curl -X POST http://localhost:8080/documents \
  -H "Content-Type: application/json" \
  -d '{
    "id": "doc1",
    "name": "Мой документ",
    "items": [
      {
        "id": "item1",
        "name": "Первый элемент",
        "sort": 10,
        "items": [
          {
            "id": "subitem1",
            "name": "Вложенный элемент",
            "data": {
              "key": "value",
              "number": 42
            }
          }
        ]
      },
      {
        "id": "item2",
        "name": "Второй элемент",
        "sort": 20,
        "items": []
      }
    ]
  }'
```

**Параметры запроса:**

| Параметр | Тип | Обязательный | Описание |
|----------|-----|--------------|----------|
| `id` | string | Да | Уникальный идентификатор документа |
| `name` | string | Да | Название документа |
| `items` | array | Нет | Массив элементов первого уровня |

**Структура элемента первого уровня:**

| Параметр | Тип | Обязательный | Описание |
|----------|-----|--------------|----------|
| `id` | string | Да | Уникальный идентификатор элемента |
| `name` | string | Да | Название элемента |
| `sort` | integer | Нет | Значение для сортировки (по убыванию) |
| `items` | array | Нет | Массив элементов второго уровня |

**Структура элемента второго уровня:**

| Параметр | Тип | Обязательный | Описание |
|----------|-----|--------------|----------|
| `id` | string | Да | Уникальный идентификатор элемента |
| `name` | string | Да | Название элемента |
| `data` | object | Нет | Произвольные данные в формате JSON |

**Успешный ответ (201 Created):**
```json
{
  "id": "doc1",
  "name": "Мой документ",
  "created_at": "2024-01-15T10:30:00Z",
  "items": [
    {
      "id": "item2",
      "name": "Второй элемент",
      "sort": 20,
      "items": []
    },
    {
      "id": "item1",
      "name": "Первый элемент",
      "sort": 10,
      "items": [
        {
          "id": "subitem1",
          "name": "Вложенный элемент",
          "data": {
            "key": "value",
            "number": 42
          }
        }
      ]
    }
  ]
}
```

**Примечание:** Элементы первого уровня автоматически сортируются по полю `sort` в порядке убывания.

**Ошибки:**

- `400 Bad Request` - Некорректный формат запроса или отсутствуют обязательные поля
- `500 Internal Server Error` - Ошибка при создании документа

---

#### Получение документа

**Endpoint:** `GET /documents/{id}`

**Описание:** Возвращает документ по его идентификатору.

**Запрос:**
```bash
curl -X GET http://localhost:8080/documents/doc1
```

**Параметры пути:**

| Параметр | Тип | Описание |
|----------|-----|----------|
| `id` | string | Идентификатор документа |

**Успешный ответ (200 OK):**
```json
{
  "id": "doc1",
  "name": "Мой документ",
  "created_at": "2024-01-15T10:30:00Z",
  "items": [
    {
      "id": "item2",
      "name": "Второй элемент",
      "sort": 20,
      "items": []
    },
    {
      "id": "item1",
      "name": "Первый элемент",
      "sort": 10,
      "items": [
        {
          "id": "subitem1",
          "name": "Вложенный элемент",
          "data": {
            "key": "value"
          }
        }
      ]
    }
  ]
}
```

**Ошибки:**

- `400 Bad Request` - Отсутствует параметр `id`
- `404 Not Found` - Документ не найден
- `500 Internal Server Error` - Ошибка при получении документа

---

#### Обновление документа

**Endpoint:** `PUT /documents/{id}`

**Описание:** Обновляет существующий документ. Идентификатор в пути должен совпадать с идентификатором в теле запроса.

**Запрос:**
```bash
curl -X PUT http://localhost:8080/documents/doc1 \
  -H "Content-Type: application/json" \
  -d '{
    "id": "doc1",
    "name": "Обновленный документ",
    "items": [
      {
        "id": "item1",
        "name": "Обновленный элемент",
        "sort": 15,
        "items": []
      }
    ]
  }'
```

**Параметры пути:**

| Параметр | Тип | Описание |
|----------|-----|----------|
| `id` | string | Идентификатор документа |

**Параметры запроса:** Аналогичны созданию документа.

**Успешный ответ (200 OK):**
```json
{
  "id": "doc1",
  "name": "Обновленный документ",
  "created_at": "2024-01-15T10:30:00Z",
  "items": [
    {
      "id": "item1",
      "name": "Обновленный элемент",
      "sort": 15,
      "items": []
    }
  ]
}
```

**Ошибки:**

- `400 Bad Request` - Некорректный формат запроса или несовпадение идентификаторов
- `500 Internal Server Error` - Ошибка при обновлении документа

---

#### Удаление документа

**Endpoint:** `DELETE /documents/{id}`

**Описание:** Удаляет документ по его идентификатору.

**Запрос:**
```bash
curl -X DELETE http://localhost:8080/documents/doc1
```

**Параметры пути:**

| Параметр | Тип | Описание |
|----------|-----|----------|
| `id` | string | Идентификатор документа |

**Успешный ответ (200 OK):**
```json
{
  "message": "document deleted"
}
```

**Ошибки:**

- `400 Bad Request` - Отсутствует параметр `id`
- `500 Internal Server Error` - Ошибка при удалении документа

---

#### Список документов

**Endpoint:** `GET /documents`

**Описание:** Возвращает список документов с поддержкой пагинации.

**Запрос:**
```bash
curl -X GET "http://localhost:8080/documents?page=1&per_page=20"
```

**Параметры запроса:**

| Параметр | Тип | Обязательный | По умолчанию | Описание |
|----------|-----|--------------|--------------|----------|
| `page` | integer | Нет | `1` | Номер страницы (начиная с 1) |
| `per_page` | integer | Нет | `20` | Количество элементов на странице (максимум 100) |

**Успешный ответ (200 OK):**
```json
{
  "data": [
    {
      "id": "doc1",
      "name": "Первый документ",
      "created_at": "2024-01-15T10:30:00Z",
      "items": []
    },
    {
      "id": "doc2",
      "name": "Второй документ",
      "created_at": "2024-01-15T11:00:00Z",
      "items": []
    }
  ],
  "pagination": {
    "page": 1,
    "per_page": 20,
    "total": 42,
    "total_pages": 3,
    "has_more": true
  }
}
```

**Поля ответа:**

| Поле | Тип | Описание |
|------|-----|----------|
| `data` | array | Массив документов |
| `pagination.page` | integer | Текущая страница |
| `pagination.per_page` | integer | Элементов на странице |
| `pagination.total` | integer | Общее количество документов |
| `pagination.total_pages` | integer | Общее количество страниц |
| `pagination.has_more` | boolean | Есть ли следующая страница |

**Ошибки:**

- `400 Bad Request` - Некорректные параметры пагинации
- `500 Internal Server Error` - Ошибка при получении списка документов

---

## Модель данных

### Document

Основная сущность - документ с вложенными элементами.

```go
type Document struct {
    ID        string       `json:"id"`         // Уникальный идентификатор
    Name      string       `json:"name"`       // Название документа
    CreatedAt time.Time    `json:"created_at"` // Время создания
    Items     []Level1Item `json:"items"`      // Элементы первого уровня
}
```

### Level1Item

Элемент первого уровня вложенности.

```go
type Level1Item struct {
    ID    string       `json:"id"`    // Уникальный идентификатор
    Name  string       `json:"name"`  // Название элемента
    Sort  int          `json:"sort"`  // Значение для сортировки (DESC)
    Items []Level2Item `json:"items"` // Элементы второго уровня
}
```

### Level2Item

Элемент второго уровня вложенности.

```go
type Level2Item struct {
    ID   string                 `json:"id"`   // Уникальный идентификатор
    Name string                 `json:"name"` // Название элемента
    Data map[string]interface{} `json:"data"` // Произвольные данные
}
```

## Разработка

### Добавление новых функций

1. Определите доменные сущности в `internal/domain/`
2. Добавьте методы репозитория в `internal/repositories/`
3. Реализуйте use cases в `internal/usecases/`
4. Создайте HTTP обработчики в `internal/handlers/`
5. Зарегистрируйте маршруты в `cmd/server/main.go`

### Особенности реализации

#### Автоматическая сортировка

Элементы первого уровня автоматически сортируются по полю `sort` в порядке убывания:

```json
// Входные данные (несортированные)
{
  "items": [
    {"id": "item1", "sort": 5},
    {"id": "item2", "sort": 20},
    {"id": "item3", "sort": 10}
  ]
}

// Выходные данные (отсортированные)
{
  "items": [
    {"id": "item2", "sort": 20},
    {"id": "item3", "sort": 10},
    {"id": "item1", "sort": 5}
  ]
}
```

#### Кэширование

- **Стратегия:** Read-through cache
- **TTL:** 15 минут (настраивается)
- **Шардирование:** 16 шардов для параллельного доступа
- **Инвалидация:** Автоматическая при Create/Update/Delete
- **Очистка:** Фоновый воркер удаляет устаревшие записи

#### Rate Limiting

- **Одновременные запросы:** Настраиваемое максимальное количество воркеров (по умолчанию: 100)
- **Основа:** Semaphore-based ограничение
- **Применение:** Ко всем CRUD операциям

#### Проверки при старте

Приложение выполняет следующие проверки при запуске:

1. **Подключение к базе данных** - Проверка доступности Reindexer
2. **Существование коллекций** - Проверка наличия необходимых коллекций
3. **Автоматическое создание** - Создание отсутствующих коллекций

При неудаче проверки приложение повторяет попытки до 5 раз с экспоненциальной задержкой.

## Тестирование

```bash
# Запуск всех тестов
go test ./...

# Запуск с покрытием
go test -cover ./...

# Запуск с детектором гонок
go test -race ./...

# Запуск с подробным выводом
go test -v ./...

# Запуск тестов конкретного пакета
go test ./internal/cache/...
go test ./internal/repositories/...
go test ./internal/usecases/...
```

## Docker

Проект использует Docker Compose для оркестрации двух сервисов: базы данных Reindexer и приложения. Сервисы работают в одной Docker сети и взаимодействуют через внутренние DNS имена.

### Архитектура сервисов

Docker Compose запускает два независимых контейнера:

1. **Reindexer** - отдельный контейнер с базой данных
2. **Приложение** - контейнер с микросервисом, который подключается к Reindexer

Приложение ожидает запуска Reindexer и проверяет его доступность через health check перед стартом.

### Сервисы

#### Reindexer

- **Образ:** `reindexer/reindexer:latest`
- **Имя сервиса:** `reindexer` (используется для подключения из приложения)
- **Порты:**
  - `6534` - HTTP API
  - `9088` - cproto binding (RPC/TCP)
  - `16534` - gRPC binding
- **Том:** `reindexer_data` для персистентности данных
- **Health Check:** Проверка доступности порта 6534
- **Ресурсы:** Ограничение CPU 1.0, память 512M

#### Приложение

- **Сборка:** Multi-stage Dockerfile
- **Имя контейнера:** `involta-app`
- **Порт:** `8080` - HTTP API
- **Health Check:** `/health` endpoint
- **Зависимости:** Запускается только после успешного health check сервиса Reindexer
- **Подключение к БД:** Использует имя сервиса `reindexer` в DSN: `cproto://reindexer:6534/db`
- **Ресурсы:** Ограничение CPU 2.0, память 1G

### Команды Docker Compose

```bash
# Запуск в фоновом режиме
docker-compose up -d

# Просмотр логов
docker-compose logs -f app

# Остановка и удаление контейнеров
docker-compose down

# Остановка и удаление контейнеров с данными
docker-compose down -v

# Пересборка образов
docker-compose build --no-cache
```

## Лицензия

MIT


